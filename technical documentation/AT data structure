ArbiTree data structure (AT):
AT tree roots are pointed at by tile pointers (the 4 bytes at the end of a tile in a chunk's tile array), and that pointer always points at a location in the serialised chunk data, relative to the starting offset of the chunk within the superchunk file. If that pointer is 0x0, the tree is interpreted as empty. Otherwise, the tree is interpreted as existent. Starting at the location the pointer points to, there is an AT list.


AT list:
an AT list is a list that can be composed of key-value pairs (KVPs) and/or key-pointer pairs (KPPs), or only anonymous nodes (ANs). there is an 0xFF byte after the last element in the list, used to specify its end.

KVP:
a KVP (key-value pair) is composed of a plain ASCII text key that ends in a colon and doesn't start with a dash (ex. "facing:") and a value.


KPP:
a KPP (key-pointer pair) is composed of a plain ASCII text key that ends with a colon and must start with a dash (ex. "-enchantments:") followed by a 32-bit pointer to another AT list.


AN:
an AN (anonymous node) is like a KVP, but the name is just ":" for values, or "-:" for pointers to other lists. an AT list made of ANs must be indexed numerically.

Value:
a value is a super-generic structure that can hold any kind of arbitrary variable. the first byte specifies the type like so:

byte value | datatype
===========================
0x00       | string
0x01       | boolean
0x10       | int8
0x11       | int16
0x12       | int32
0x13       | int64
0x1F       | dynamic number


string:

a string's bytes are all stored consecutively, with a 0x00 byte at the end to termimate the string. the datatype's on-screen name is "s".

s "Wow!" -> 00 57 6F 77 21 00
             .  W  o  w  !  .


boolean:

a boolean is either a 0x00 for false, or 0x01 for true. the datatype's on-screen name is "b".

b false -> 01 00
b true  -> 01 01


int8:

an int8 is an 8-bit integer, kept in one byte, with an offset of -128. the datatype's on-screen name is "i8".

i8 -128 -> 10 00
i8 0    -> 10 80
i8 100  -> 10 E4
i8 127  -> 10 FF


int16, int32, and int64 work just like int8, with offsets of -32,768, -2,147,483,648, and -9,223,372,036,854,775,808 respectively. their bytes are arranged little-endian. the datatypes' on-screen names are "i16", "i32", and "i64" respectively.

i16 256   -> 11 00 81
i32 100   -> 12 64 00 00 10
i64 -1000 -> 13 17 FC FF FF FF FF FF 7F


dynamic number:

a dynamic number is a fixed-point number whose integer width and decimal width, in bytes, are specified with the second and third bytes. for example, 1F 00 02 ... represents a dynamic number with a 0 bit (0 byte) integer part and a 16-bit (2 bytes) decimal part. the bytes of the full fixed-point number are arranged little-endian. the datatype's on-screen name is "d[byte length of integer part in decimal].[byte length of fractional part in decimal]".

d1.1 12.125  -> 1F 01 01 20 0C
d2.4 60000.1 -> 1F 02 04 99 99 99 19 60 EA


indexing:

accessing a specific item somewhere in an AT tree can be done in two ways. the first is done by concatenating the names of the lineage from the root to the item, placing colons between each. "-bunny:-pos:y" will return the value of the y position of the bunny the below AT tree belongs to, "d1.2 2.5".

-bunny:(-pos:(x:d1.2 3.0,y:d1.2 2.5),-behaviors:(following_player:b true, player_affinity:i8 60))

the second way is by indexing with numbers. the x position of the bunny can also be accessed with "-bunny:0:1". This indexes AT lists in alphabetical order, picking the first if the index number is 0, the second if the index number is 1, and so on. numerical indexing is necessary for AT lists made of anonymous nodes.

these indexing methods can be used simultaneously within the same tree path, as well, for example, "-bunny:pos:1" also accesses the y position of the bunny.

individual values can be indexed byte-by-byte, as well. "-bunny:pos:x:1" returns the second byte of the x position. value metadata is excluded from this. for example, indexing the below AT tree with "var:0" fetches 0x64, not 0x11.

plaintext tree | full data | raw value
======================================
var:i16 100    | 11 64 00  | 64 00


















